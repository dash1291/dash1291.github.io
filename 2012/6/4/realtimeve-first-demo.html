<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="viewport" content="width=device-width" />
    <title> Collaborative VisualEditor: First Demo |Ashish Dubey's Blog</title>
    <link rel="stylesheet" href="/newblog/static/style.css" type="text/css"/>

  </head>
  <body>
    <div id="container">
      <div id="header">
        <div id="nav">
          <ul>
						<li><a href="/newblog">Home</a></li>
						<li><a href="http://ytfm.ashishdubey.info/blog">Old Blog</a></li>
            <li><a href="/newblog/posts.html">Archive</a></li>
            <li><a href="/newblog/about.html">About</a></li>
          </ul>
        </div>
      </div>
      <div id="content">
  <div class="post">
    <h1>Collaborative VisualEditor: First Demo </h2>
    <div class="post-meta">
      <span class="post-date">Posted on June 04, 2012 </span>
    </div>
    <div class="post-content">
      <p>I feel pretty ---- for not having written about my Google Summer of Code project that I'm undertaking this summer for Wikimedia Foundation for prototyping collaborative editing feature for the new under-development VisualEditor(wysiwyg). Its been a while since I was selected, and started working on it, so I won't go into discussing the story around how I got started on it. But, I would like to discuss about the present state of the project, where its heading and also a bare working demo of the code produced so far.</p>

<p>So the VisualEditor project is a wysiwyg editor for MediaWiki, designed from scratch keeping in mind the complexities of the Wikitext mapping to HTML and data structures suitable for inline editing. The changes to the text in VisualEditor are in the form of transactions. There are transactions for insertion/deletion of text as well as applying formatting attributes to a portion of text.
So most of the collaboration thing revolves around these transactions. There is a collaboration server which listens for new connections from clients who requests to initiate an editing session. A client module establishes connection with the server, and listens to the changes made in the document and translates the resulting transactions to the server. A thing that should be noted here, is the project is under Phase 1 which would support only one client who publishes changes to the server's document and other connected clients simply listen to these changes and apply them in their local documents. Phase 2 would support multiple publishers which would bring in conflicts and concurrency issues and perhaps measures to fight with them.</p>

<p>So, there is a small list of things which have been done so far -</p>

<h2>On the Server</h2>

<ol>
<li>Listen to new connections and define I/O events.</li>
<li>Bind the VE modules into a single module which is imported as a top-level <code>ve</code> object.</li>
<li>Create a new user session on every new connection and associate with the requested document.</li>
<li>Create a new document model instance if an editing session is initiated on a new document.</li>
<li>Apply incoming transactions to the document model.</li>
<li>Invoke/revoke publishing rights on user sessions.</li>
</ol>

<h2>On the Client</h2>

<ol>
<li>Initialize a new session with the server on manual request.</li>
<li>Enable/Disable editing based on publishing right flag received from the server.</li>
<li>Listen to document change events and push transactions to the server if publishing is given.</li>
<li>Apply incoming transaction from the server if the origin of the transaction is a different client.</li>
<li>Retain the document state before collaborative editing is turned on so it can be restored when collaborative mode is turned off.</li>
</ol>

<h2>Brief Internals</h2>

<p>The collaboration server is a Node.js based server, which uses socket.io for making persistent connections with the clients for realtime communication. The client module binds against the server's API which is laid in terms of the socket.io events defined in the server. All the VE functionality is accessed through a binding module which exports a top-level <code>ve</code> object much like the <code>ve</code> namespace is used on the client-side. The server can parse the wiki pages internally using the parser modules and also can fetch the parsed HTML output from an external parsoid service over HTTP. As of now, external service is used for scalability until something better can be figured out.</p>

    </div>
  </div>
  <hr class="post-end"/>
  <div id="disqus_thread"></div>
  <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'ashishdubeysblog'; // required: replace example with your forum shortname
     // var disqus_developer = 1

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
			<div id="footer">

				<span class="grey-italic">Copyright &copy 2012 Ashish Dubey. Powered by <a href="/newblog/about.html#aboutsite">{}</a></span>
      </div>
    </div>
  </body>
</html>